import fs from "node:fs"
import path from "node:path"
import {
	app,
	BrowserWindow,
	dialog,
	ipcMain,
	Menu,
	nativeImage,
	protocol,
	session,
	shell,
} from "electron"
import { productName, version } from "../package.json"
import { BODYGEN_RELATIVE_PATH } from "./consts"
import {
	applyMigrations,
	multiRulesDB,
	readConfig,
	rulesDB,
	singleRulesDB,
	writeConfig,
} from "./db"
// @ts-expect-error
import icon from "./images/icon.png"
import {
	formatINIs,
	parseTemplates,
	resolveBodySlidePresets,
	resolveCategorisedSliders,
	resolveESMs,
	resolveNPCsFormIDs,
	resolveRacesFormIDs,
	resolveSliders,
	validateESMs,
	validateTemplates,
	write,
	zipFolder,
} from "./utils"

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
	app.quit()
}

protocol.registerSchemesAsPrivileged([
	{
		scheme: "presets",
		privileges: {
			standard: true,
			secure: true,
			supportFetchAPI: true,
			corsEnabled: true,
		},
	},
])

const fileSystemFix = () => {
	// https://www.electronjs.org/docs/latest/api/session#event-file-system-access-restricted
	session.defaultSession.on(
		"file-system-access-restricted",
		async (_e, details, callback) => {
			const { origin, path } = details
			const { response } = await dialog.showMessageBox({
				message: `Are you sure you want ${origin} to open restricted path ${path}?`,
				title: "File System Access Restricted",
				buttons: ["Choose a different folder", "Allow", "Cancel"],
				cancelId: 2,
			})

			if (response === 0) {
				callback("tryAgain")
			} else if (response === 1) {
				callback("allow")
			} else {
				callback("deny")
			}
		},
	)
}
let mainWindow: BrowserWindow

const loadTemplates = (from: string) => {
	return fs.readFileSync(from).toString()
}

const createWindow = (): void => {
	// Create the browser window.
	mainWindow = new BrowserWindow({
		height: 600,
		width: 800,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
			nodeIntegration: false,
			nodeIntegrationInWorker: false,
			contextIsolation: true,
		},
		icon: nativeImage.createFromDataURL(icon),
	})

	// and load the index.html of the app.
	void mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).then(() => {
		mainWindow.setTitle(`${productName} v${version}`)
	})

	// Open the DevTools.
	!app.isPackaged && mainWindow.webContents.openDevTools()

	Menu.setApplicationMenu(null)

	fileSystemFix()
}

const openFileSystemDialog = async (
	options: Electron.OpenDialogOptions,
	folder: "dataFolder" | "outputFolder",
) => {
	const { filePaths } = await dialog.showOpenDialog(options)
	const filePath = filePaths?.[0]
	writeConfig(folder, filePath ? filePath : "")
	return readConfig()
}

const handleNavigate = (page: string) => {
	writeConfig("lastActiveLocation", page)
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.

app.whenReady().then(() => {
	applyMigrations()

	session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
		const responseHeaders = details.responseHeaders ?? {}
		const csp = app.isPackaged
			? "default-src 'self' 'unsafe-inline' data:; img-src 'self' data: presets:;"
			: "default-src 'self' 'unsafe-inline' 'unsafe-eval' data:; img-src 'self' data: presets:;"
		responseHeaders["Content-Security-Policy"] = [csp]
		callback({ responseHeaders })
	})

	const baseDir = app.isPackaged
		? path.resolve(app.getAppPath(), "..")
		: process.cwd()
	const presetsDir = path.resolve(baseDir, "data", "presets")
	protocol.registerFileProtocol("presets", (request, callback) => {
		const url = new URL(request.url)
		let rel = decodeURIComponent(`${url.hostname}${url.pathname || ""}`)
		rel = rel.replace(/^\/+/, "").replace(/\/+$/, "")
		if (rel.toLowerCase().startsWith("local/")) {
			rel = rel.slice("local/".length)
		}
		const filePath = path.normalize(path.join(presetsDir, rel))
		if (!filePath.startsWith(presetsDir)) {
			callback({ error: -10 })
			return
		}
		callback({ path: filePath })
	})

	createWindow()

	ipcMain.handle(
		"dialog:openDataFolder",
		(_event, folder: "dataFolder" | "outputFolder") =>
			openFileSystemDialog(
				{
					title: "Select Fallout 4 data folder",
					properties: ["openDirectory"],
				},
				folder,
			),
	)
	ipcMain.handle("readConfig", readConfig)
	ipcMain.handle("resolveSliders", () => {
		const config = readConfig()
		if (!config.dataFolder) return { 0: [], 1: [] }
		return resolveSliders(config.dataFolder)
	})
	ipcMain.handle("resolveCategorisedSliders", () => {
		const config = readConfig()
		if (!config.dataFolder) return { 0: {}, 1: {} }
		return resolveCategorisedSliders(config.dataFolder)
	})
	ipcMain.handle("templates:load", (_event, from: string) =>
		loadTemplates(from),
	)
	ipcMain.handle("templates:parse", (_event, content: string) =>
		parseTemplates(content),
	)
	ipcMain.handle("templates:readDefault", () => {
		const dataFolder = readConfig().dataFolder
		if (!dataFolder) return ""
		const defaultTemplatesPath = path.resolve(
			dataFolder,
			...BODYGEN_RELATIVE_PATH,
			"Fallout4.esm",
			"templates.ini",
		)
		if (!fs.existsSync(defaultTemplatesPath)) {
			return ""
		}
		return fs.readFileSync(defaultTemplatesPath).toString()
	})
	ipcMain.handle("templates:validate", (_event, content: string) => {
		try {
			validateTemplates(content)
			return ""
		} catch (error) {
			return error instanceof Error ? error.message : String(error)
		}
	})
	ipcMain.handle("format", (_event, content: string) => formatINIs(content))
	ipcMain.handle("write", (_event, from: string, content: string) => {
		const config = readConfig()
		if (!config.dataFolder) return "Data folder not set."
		if (!config.outputFolder) return "Output folder not set."
		let outputFolder = config.outputFolder
		if (outputFolder !== config.dataFolder) {
			outputFolder = path.resolve(
				config.outputFolder,
				"BodyGen",
				...BODYGEN_RELATIVE_PATH,
			)
		} else {
			outputFolder = path.resolve(outputFolder, ...BODYGEN_RELATIVE_PATH)
		}
		return write(from, outputFolder, content)
	})
	ipcMain.handle("ESM:resolve", (_events, from: string) => resolveESMs(from))
	ipcMain.handle("ESM:validate", (_events, from: string, content: string) =>
		validateESMs(from, content),
	)
	ipcMain.handle("resolveBodySlidePresets", (_events, from: string) =>
		resolveBodySlidePresets(from),
	)

	ipcMain.handle("resolveNPCs", () =>
		resolveNPCsFormIDs(
			path.resolve(
				app.getAppPath(),
				app.isPackaged ? ".." : "",
				"FormIDs",
				"NPCs",
			),
		),
	)
	ipcMain.handle("resolveRaces", () =>
		resolveRacesFormIDs(
			path.resolve(
				app.getAppPath(),
				app.isPackaged ? ".." : "",
				"FormIDs",
				"Races",
			),
		),
	)

	ipcMain.handle("zipOutput", async () => {
		const config = readConfig()
		if (!config.outputFolder) return "Output folder not set."
		if (config.outputFolder === config.dataFolder) {
			return "No need to zip, output folder is the same as data folder."
		}
		await zipFolder(
			path.resolve(config.outputFolder, "BodyGen"),
			path.resolve(config.outputFolder, "BodyGen.zip"),
		)
		return path.resolve(config.outputFolder, "BodyGen.zip")
	})

	ipcMain.handle(
		"singleRulesDB",
		(_event, action: keyof typeof singleRulesDB, ...rest: any[]) => {
			// @ts-expect-error
			return singleRulesDB[action](...rest)
		},
	)
	ipcMain.handle(
		"multiRulesDB",
		(_event, action: keyof typeof multiRulesDB, ...rest: any[]) => {
			// @ts-expect-error
			return multiRulesDB[action](...rest)
		},
	)
	ipcMain.handle(
		"rulesDB",
		(_event, action: keyof typeof rulesDB, ...rest: any[]) => {
			// @ts-expect-error
			return rulesDB[action](...rest)
		},
	)

	ipcMain.on("navigate", (_event, page: string) => handleNavigate(page))
	ipcMain.on("openExternal", (_event, url: string) => shell.openExternal(url))

	// On macOS it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	app.on("activate", () => {
		if (BrowserWindow.getAllWindows().length === 0) {
			createWindow()
		}
	})
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
	if (process.platform !== "darwin") {
		app.quit()
	}
})

app.on("activate", () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow()
	}
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
