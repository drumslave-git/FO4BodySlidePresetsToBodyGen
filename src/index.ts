import fs from "node:fs"
import path from "node:path"
import { app, BrowserWindow, dialog, ipcMain, Menu, session } from "electron"
import type { Location } from "react-router"

import type { Config } from "./types"
import {
	formatINIs,
	resolveBodySlidePresets,
	resolveESMs,
	validateESMs,
	validateTemplates,
	write,
} from "./utils"

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
	app.quit()
}

const fileSystemFix = () => {
	// https://www.electronjs.org/docs/latest/api/session#event-file-system-access-restricted
	session.defaultSession.on(
		"file-system-access-restricted",
		async (e, details, callback) => {
			const { origin, path } = details
			const { response } = await dialog.showMessageBox({
				message: `Are you sure you want ${origin} to open restricted path ${path}?`,
				title: "File System Access Restricted",
				buttons: ["Choose a different folder", "Allow", "Cancel"],
				cancelId: 2,
			})

			if (response === 0) {
				callback("tryAgain")
			} else if (response === 1) {
				callback("allow")
			} else {
				callback("deny")
			}
		},
	)
}
let mainWindow: BrowserWindow

const CONFIG_PATH = path.resolve(__dirname, "..", "..", "data", "config.json")
const loadConfig = (): Config => {
	if (!fs.existsSync(CONFIG_PATH)) {
		return {}
	}
	try {
		const configContent = fs.readFileSync(CONFIG_PATH)
		return JSON.parse(configContent.toString())
	} catch (error) {
		console.error("Error reading config file:", error)
		return {}
	}
}

const saveConfig = (data: Partial<Config>) => {
	try {
		const config = loadConfig()
		fs.writeFileSync(
			CONFIG_PATH,
			JSON.stringify({ ...config, ...data }, null, 2),
		)
	} catch (error) {
		console.error("Error saving config file:", error)
	}
}

const loadTemplates = () => {
	return fs.readFileSync(loadConfig().templatesFile).toString()
}

const createWindow = (): void => {
	// Create the browser window.
	mainWindow = new BrowserWindow({
		height: 600,
		width: 800,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
		},
	})

	// and load the index.html of the app.
	mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

	// Open the DevTools.
	mainWindow.webContents.openDevTools()

	Menu.setApplicationMenu(null)

	fileSystemFix()
}

const openFileSystemDialog = async (
	options: Electron.OpenDialogOptions,
	field: keyof Config,
) => {
	const { canceled, filePaths } = await dialog.showOpenDialog(options)
	saveConfig({ [field]: undefined })
	if (!canceled) {
		saveConfig({ [field]: filePaths[0] })
		return filePaths[0]
	}
}

const handleNavigate = (location: Location) => {
	saveConfig({
		lastActiveLocation: location.pathname,
	})
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.

app.whenReady().then(() => {
	createWindow()

	ipcMain.handle("dialog:openTemplates", () =>
		openFileSystemDialog(
			{
				title: "Select source templates file",
				properties: ["openFile"],
				filters: [{ name: "INI Files", extensions: ["ini"] }],
			},
			"templatesFile",
		),
	)
	ipcMain.handle("dialog:openDataFolder", () =>
		openFileSystemDialog(
			{
				title: "Select Fallout 4 data folder",
				properties: ["openDirectory"],
			},
			"dataFolder",
		),
	)
	ipcMain.handle("loadConfig", loadConfig)
	ipcMain.handle("templates:load", loadTemplates)
	ipcMain.handle("templates:validate", (_event, content: string) => {
		try {
			validateTemplates(content)
			return ""
		} catch (error) {
			return error.message
		}
	})
	ipcMain.handle("format", (_event, content: string) => formatINIs(content))
	ipcMain.handle("write", (_event, content: string) =>
		write(loadConfig().templatesFile, content),
	)
	ipcMain.handle("ESM:resolve", (_events, from: string) => resolveESMs(from))
	ipcMain.handle("ESM:validate", (_events, from: string, content: string) =>
		validateESMs(from, content),
	)
	ipcMain.handle("resolveBodySlidePresets", (_events, from: string) =>
		resolveBodySlidePresets(from),
	)

	ipcMain.on("navigate", (_event, location: Location) =>
		handleNavigate(location),
	)

	// On macOS it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	app.on("activate", () => {
		if (BrowserWindow.getAllWindows().length === 0) {
			createWindow()
		}
	})
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
	if (process.platform !== "darwin") {
		app.quit()
	}
})

app.on("activate", () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow()
	}
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
