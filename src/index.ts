import fs from "node:fs"
import path from "node:path"
import {
	app,
	BrowserWindow,
	dialog,
	ipcMain,
	Menu,
	nativeImage,
	session,
	shell,
} from "electron"
import type { Location } from "react-router"
import { name, version } from "../package.json"
import { BODYGEN_RELATIVE_PATH } from "./consts"
// @ts-expect-error
import icon from "./images/icon.png"
import type { Config } from "./types"
import {
	formatINIs,
	parseTemplates,
	resolveBodySlidePresets,
	resolveESMs,
	validateESMs,
	validateTemplates,
	write,
	zipFolder,
} from "./utils"

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
	app.quit()
}

const fileSystemFix = () => {
	// https://www.electronjs.org/docs/latest/api/session#event-file-system-access-restricted
	session.defaultSession.on(
		"file-system-access-restricted",
		async (_e, details, callback) => {
			const { origin, path } = details
			const { response } = await dialog.showMessageBox({
				message: `Are you sure you want ${origin} to open restricted path ${path}?`,
				title: "File System Access Restricted",
				buttons: ["Choose a different folder", "Allow", "Cancel"],
				cancelId: 2,
			})

			if (response === 0) {
				callback("tryAgain")
			} else if (response === 1) {
				callback("allow")
			} else {
				callback("deny")
			}
		},
	)
}
let mainWindow: BrowserWindow

const APP_DIR = app.isPackaged
	? path.dirname(process.resourcesPath)
	: process.cwd()
const CONFIG_PATH = path.join(app.getPath("userData"), "config.json")

const defaultConfig = (config: Config) => {
	const defaults = {
		...config,
	}
	if (!defaults.outputFolder && defaults.dataFolder) {
		defaults.outputFolder = defaults.dataFolder
	}
	return defaults
}
const loadConfig = (): Config => {
	if (!fs.existsSync(CONFIG_PATH)) {
		return {}
	}
	let config: Config = {}
	try {
		const configContent = fs.readFileSync(CONFIG_PATH)
		config = JSON.parse(configContent.toString())
	} catch (error) {
		console.error("Error reading config file:", error)
	}

	return defaultConfig(config)
}

const saveConfig = (data: Partial<Config>) => {
	try {
		const config = loadConfig()
		fs.writeFileSync(
			CONFIG_PATH,
			JSON.stringify({ ...config, ...data }, null, 2),
		)
	} catch (error) {
		console.error("Error saving config file:", error)
	}
}

const loadTemplates = (from: string) => {
	return fs.readFileSync(from).toString()
}

const createWindow = (): void => {
	// Create the browser window.
	mainWindow = new BrowserWindow({
		height: 600,
		width: 800,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
		},
		icon: nativeImage.createFromDataURL(icon),
	})

	// and load the index.html of the app.
	void mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).then(() => {
		mainWindow.setTitle(`${name} v${version}`)
	})

	// Open the DevTools.
	!app.isPackaged && mainWindow.webContents.openDevTools()

	Menu.setApplicationMenu(null)

	fileSystemFix()
}

const openFileSystemDialog = async (
	options: Electron.OpenDialogOptions,
	folder: "dataFolder" | "outputFolder",
) => {
	const { filePaths } = await dialog.showOpenDialog(options)
	const filePath = filePaths?.[0]
	saveConfig({ [folder]: filePath ? filePath : undefined })
	return loadConfig()
}

const handleNavigate = (location: Location) => {
	saveConfig({
		lastActiveLocation: location.pathname,
	})
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.

app.whenReady().then(() => {
	createWindow()

	ipcMain.handle(
		"dialog:openDataFolder",
		(_event, folder: "dataFolder" | "outputFolder") =>
			openFileSystemDialog(
				{
					title: "Select Fallout 4 data folder",
					properties: ["openDirectory"],
				},
				folder,
			),
	)
	ipcMain.handle("loadConfig", loadConfig)
	ipcMain.handle("resolveConfigPath", () => CONFIG_PATH)
	ipcMain.handle("templates:load", (_event, from: string) =>
		loadTemplates(from),
	)
	ipcMain.handle("templates:parse", (_event, content: string) =>
		parseTemplates(content),
	)
	ipcMain.handle("templates:readDefault", () => {
		const defaultTemplatesPath = path.resolve(
			loadConfig().dataFolder,
			...BODYGEN_RELATIVE_PATH,
			"Fallout4.esm",
			"templates.ini",
		)
		if (!fs.existsSync(defaultTemplatesPath)) {
			return ""
		}
		return fs.readFileSync(defaultTemplatesPath).toString()
	})
	ipcMain.handle("templates:validate", (_event, content: string) => {
		try {
			validateTemplates(content)
			return ""
		} catch (error) {
			return error.message
		}
	})
	ipcMain.handle("format", (_event, content: string) => formatINIs(content))
	ipcMain.handle("write", (_event, from: string, content: string) => {
		const config = loadConfig()
		let outputFolder = config.outputFolder
		if (outputFolder !== config.dataFolder) {
			outputFolder = path.resolve(
				loadConfig().outputFolder,
				"BodyGen",
				...BODYGEN_RELATIVE_PATH,
			)
		} else {
			outputFolder = path.resolve(outputFolder, ...BODYGEN_RELATIVE_PATH)
		}
		return write(from, outputFolder, content)
	})
	ipcMain.handle("ESM:resolve", (_events, from: string) => resolveESMs(from))
	ipcMain.handle("ESM:validate", (_events, from: string, content: string) =>
		validateESMs(from, content),
	)
	ipcMain.handle("resolveBodySlidePresets", (_events, from: string) =>
		resolveBodySlidePresets(from),
	)
	ipcMain.handle("path:resolve", (_events, ...args) =>
		path.resolve(...(args.length ? args : [APP_DIR])),
	)
	ipcMain.handle("zipOutput", async () => {
		const config = loadConfig()
		if (config.outputFolder === config.dataFolder) {
			return "No need to zip, output folder is the same as data folder."
		}
		await zipFolder(
			path.resolve(config.outputFolder, "BodyGen"),
			path.resolve(config.outputFolder, "BodyGen.zip"),
		)
		return path.resolve(config.outputFolder, "BodyGen.zip")
	})

	ipcMain.on("navigate", (_event, location: Location) =>
		handleNavigate(location),
	)
	ipcMain.on("openExternal", (_event, url: string) => shell.openExternal(url))

	// On macOS it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	app.on("activate", () => {
		if (BrowserWindow.getAllWindows().length === 0) {
			createWindow()
		}
	})
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
	if (process.platform !== "darwin") {
		app.quit()
	}
})

app.on("activate", () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow()
	}
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
